
*** Introduction

Makeconf is a build system for C programs. It was inspired by GNU Autoconf, and tries to be backwards compatible from an end-user perspective.  Makeconf allows you to specify information that you need to build software, and then it generates a configure script for you. This script takes care of generating a makefile that can build your software package.

While the configure script that makeconf generates looks very similar to that generated by Autoconf, there are some fundamental design differences between the two tools.

 - Graphical user interface
 - Ruby vs M4sh
 - OOP versus macro programming
 - Recursive Makefiles
 - Microsoft Windows support
 - Generated files

*** Elements of a Build System

*** Installing Makeconf 

To install makeconf, you need to have Ruby 1.8 or higher.  There are several ways of installing Makeconf.

  --FIXME -- libxml-ruby gem required for XML validation

 - Compile from source -

You can download the makeconf source code, build your own gem, and install it. Run this command to build the gem:

make all 

Then run this command to install the gem, assuming you have root access:

sudo gem install makeconf-*.gem

If you do not have root access, you can install Makeconf in your home directory by running this command:

gem install -i ~/.makeconf ./makeconf-*.gem

 - RubyGems -

Run the following command to download and install the gem from the RubyGems server:

gem install makeconf

*** Anatomy of a configure script

The configure script is very simple, and is a one-line shell script that invokes the Ruby interpreter to execute the setup.rb script. Here is an example:

exec ruby -- setup.rb $*

This script is intended to be run on Unix platforms in exactly the same way as you would run an Autoconf configure script.

*** The setup.rb script

The first step is to tell Ruby where to find the makeconf library. This example will load makeconf from a subdirectory named 'makeconf'.

   $LOAD_PATH <<  'makeconf'

The next thing is to load the makeconf library:

  require 'makeconf'

The final step is to call Makeconf.new and provide the information needed to build the project. Here is a simple example showing the minimum required fields:

  Makeconf.new( 
	:id => 'hello', 
     :binaries => {
          'hello_world' => {
              :sources => [ '*.c' ],
           },
     })

Here is a more complete example:

  Makeconf.new(
    :id => 'hello',
  :version => '0.8.2',
  :license => 'BSD',
  :author => 'Mark Heily',
  :summary => 'pthread_workqueue library',
  :description => 'pthread_workqueue library',
  :extra_dist => ['LICENSE', 'src/*.[ch]', 'src/*/*.[ch]'],
  :manpages => 'pthread_workqueue.3',
  :headers => 'pthread_workqueue.h',
  :libraries => {
     'libpthread_workqueue' => {
        :cflags => cflags,
        :sources => sources,
        :ldadd => ldadd,
        },
  },
  :tests => {
    'api' => {
        :sources => [ 'testing/api/test.c' ],
        :ldadd => ['-lpthread_workqueue', ldadd ]
        },
    'latency' => {
        :sources => [ 'testing/latency/latency.c' ],
        :ldadd => ['-lpthread_workqueue', ldadd ]
    },
    'witem_cache' => {
        :sources => [ 'testing/witem_cache/test.c' ],
        :ldadd => ['-lpthread_workqueue', ldadd ]
    },
  }
)

*** Using a configure script

*** Makeconf API Reference
